// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Circle {
    float3 center;
    float r;
    float4 color;
};

struct Triangle {
    float3 a;
    float3 b;
    float3 c;
    float3 midAB;
    float3 midBC;
    float3 midCA;
    float4 color;
};

struct Quad {
    float3 a;
    float3 b;
    float3 c;
    float3 d;

    float3 midAB;
    float3 midBC;
    float3 midCD;
    float3 midDA;

    float4 color;
};

// objects
StructuredBuffer<Circle> circles;
uint cLength;

StructuredBuffer<Triangle> triangles;
uint tLength;

StructuredBuffer<Quad> quads;
uint qLength;

// bg
float4 bgColor;
float4 orthoBg;
bool useBgTexture = false;
Texture2D bgTexture;
float2 bgStep;

// rays
float4x4 screenQ;
StructuredBuffer<float3> rays;
int2 resolution;
RWTexture2D<float4> Result;

// functions

// converts cartesian to spherical
float2 Cartesian2Spherical(float3 v) {
    float2 position = float2(0, 0);
    float3 v_ = float3(v[0], v[1], v[2]);

    v_ /= length(v_);
    position[1] = asin(v_[1]);
    float cosOfz = cos(v_[1]);
    position[0] = atan2(v_[2] / cosOfz, v_[0] / cosOfz);

    return position;
}

// gets bg color
float4 getBgColor(float2 v) {
    v[0] += 3.1416;//*2*(v[0] < 0);
    v[1] += 3.1416*0.5;
    float4 finalBgColor = bgColor;
    if (useBgTexture) {
        int2 texPos = int2((int)((v.x - (v.x % bgStep.x)) / bgStep.x), (int)((v.y - (v.y % bgStep.y)) / bgStep.y));
        finalBgColor *= bgColor.a;
        finalBgColor += bgTexture[texPos] * (1-bgColor.a);
    }
    finalBgColor.a = 1;
    return finalBgColor;
}

// collision with circle
bool collidePointCircle(float3 v, Circle c) {
    return acos(dot(v, c.center)) < c.r;
}

// collision with triangle
bool collidePointTriangle(float3 v, Triangle t) {
    return ((dot(t.a, v - t.midAB) <= 0) && (dot(t.b, v - t.midBC) <= 0) && (dot(t.c, v - t.midCA) <= 0));
}

// collision with quad
bool collidePointQuad(float3 v, Quad q) {
    return ((dot(q.a, v - q.midAB) <= 0) && (dot(q.b, v - q.midBC) <= 0) && (dot(q.c, v - q.midCD) <= 0) && (dot(q.d, v - q.midDA) <= 0));
}

bool isOut(float3 v) {
    return (abs(v.x) + abs(v.y) + abs(v.z)) > 5;
}

// main function
[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    float3 ray = mul(screenQ, float4(rays[(resolution[1] * id.x) + id.y], 0)).xyz;
    float2 raySph = Cartesian2Spherical(ray);

    float4 finalColor = getBgColor(raySph);
    bool collided = false;

    // circles
    for (int i = 0; i < cLength; i++) {
        collided = collidePointCircle(ray, circles[i]);
        finalColor = (collided * circles[i].color) + (!collided * finalColor);
    }

    // triangles
    for (int j = 0; j < tLength; j++) {
        collided = collidePointTriangle(ray, triangles[j]);
        finalColor = (collided * triangles[j].color) + (!collided * finalColor);
    }

    // quads
    for (int k = 0; k < qLength; k++) {
        collided = collidePointQuad(ray, quads[k]);
        finalColor = (collided * quads[k].color) + (!collided * finalColor);
    }

    // checking if ray out
    collided = isOut(ray);
    finalColor = (collided * orthoBg) + (!collided * finalColor);

    Result[id.xy] = finalColor;
}
